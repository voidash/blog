<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Introducing Nushell | AshLogs</title>
<meta name=keywords content>
<meta name=description content="At it&rsquo;s core Shells are just interactive user interface that exposes OS tools and services. This blog is a introduction to Nushell , a cross-platform shell written in Rust . We already have had fair share of shells like Bash, Zsh, Fish etc. Why do we need yet another shell? All existing shells have one thing in common, They all treat as if everything is a text. Enter Nushell where Everything is a structured data.">
<meta name=author content>
<link rel=canonical href=https://voidash.github.io/blog/posts/2022/introducing-nushell/>
<link crossorigin=anonymous href=/blog/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/blog/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://voidash.github.io/blog/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://voidash.github.io/blog/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://voidash.github.io/blog/favicon-32x32.png>
<link rel=apple-touch-icon href=https://voidash.github.io/blog/apple-touch-icon.png>
<link rel=mask-icon href=https://voidash.github.io/blog/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.2">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>
<script>MathJax={tex:{displayMath:[['\\[','\\]'],['$$','$$']],inlineMath:[['$','$']]}}</script>
<meta property="og:title" content="Introducing Nushell">
<meta property="og:description" content="At it&rsquo;s core Shells are just interactive user interface that exposes OS tools and services. This blog is a introduction to Nushell , a cross-platform shell written in Rust . We already have had fair share of shells like Bash, Zsh, Fish etc. Why do we need yet another shell? All existing shells have one thing in common, They all treat as if everything is a text. Enter Nushell where Everything is a structured data.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://voidash.github.io/blog/posts/2022/introducing-nushell/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-29T20:07:44+05:45">
<meta property="article:modified_time" content="2022-01-29T20:07:44+05:45">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Introducing Nushell">
<meta name=twitter:description content="At it&rsquo;s core Shells are just interactive user interface that exposes OS tools and services. This blog is a introduction to Nushell , a cross-platform shell written in Rust . We already have had fair share of shells like Bash, Zsh, Fish etc. Why do we need yet another shell? All existing shells have one thing in common, They all treat as if everything is a text. Enter Nushell where Everything is a structured data.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://voidash.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Introducing Nushell","item":"https://voidash.github.io/blog/posts/2022/introducing-nushell/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Introducing Nushell","name":"Introducing Nushell","description":"At it\u0026rsquo;s core Shells are just interactive user interface that exposes OS tools and services. This blog is a introduction to Nushell , a cross-platform shell written in Rust . We already have had fair share of shells like Bash, Zsh, Fish etc. Why do we need yet another shell? All existing shells have one thing in common, They all treat as if everything is a text. Enter Nushell where Everything is a structured data.","keywords":[],"articleBody":"At it’s core Shells are just interactive user interface that exposes OS tools and services. This blog is a introduction to Nushell , a cross-platform shell written in Rust . We already have had fair share of shells like Bash, Zsh, Fish etc. Why do we need yet another shell? All existing shells have one thing in common, They all treat as if everything is a text. Enter Nushell where Everything is a structured data.\nBash and Nushell : Head to Head Bash lets say you need to list directories only in bash.\nls -l | grep ^d will do the trick. How does this work? When you ls and look at each line, The line with directories will always have d present as a first character. Something like this\ndrwxr-xr-x 8 cdjk cdjk 4096 Jan 24 18:44 Documents | ┴── First character is d So we list all the contents in current directory then pipe it to grep command which looks for all the lines in a piped text that starts with d. Now that is not bad for a bash script.\nwhat if we want to get all the directories , then get its size and later list only those that are bigger than 1 gigabyte. Try doing that using ls and grep.\nFor this scenario one option is to du -sm * | awk '$1  1000' where du -sm * gets the size and name of files present in the current directory seperated by space. The output without the awk part will be\n331\tDesktop 209\tDevanagari-To-Braille-DTB 1\tdevelop 20887\tDocuments 11734\tDownloads Awk is a mini excel basically. From the awk perspective the above output by du has two fields : $1 and $2 seperated by space. First field or $1 is numeric. i.e 331, 209. It is actually a size of the file present in second field. i.e Desktop, Documents\nawk '$1  1000' will compare the first field or size that’s bigger than 1000mb and print only those lines that meet the criteria. So when piped together to form du -sm * | awk '$1  1000' This will list the contents with size bigger than 1000mb.\nThose two tasks of listing directory only and getting directory with size bigger than 1000mb look similar but we used 4 tools. For first tak we used ls and grep. For second task we used du and awk. It’s really a burden when scripting in bash due to sheer amount of tools and types of workflows present in bash. my thought process while scripting in bash is first google, then look at man pages to fit the criteria in a loop until whole script is complete and this process is really tiresome.\nNushell Nushell is different and intuitive. To demostrate that Lets perform the same task in nushell.\nls | where type == Dir | each { du $it.name } | where physical  1000mb.\nDoesn’t it look comprehensive than the bash counterpart. Isn’t it intuitive? and all in all we are just using commands ls and du.\nHere is the whole process dissected for better understanding plus some features about nushell.\n First list the contents in directory using ls  ───┬──────────────────────┬──────┬──────────┬────────────── # │ name │ type │ size │ modified ───┼──────────────────────┼──────┼──────────┼────────────── 0 │ 2022-01-24_18-44.png │ File │ 281.0 KB │ 5 days ago 1 │ asset │ Dir │ 4.1 KB │ 2 months ago 2 │ course 4th Sem │ Dir │ 4.1 KB │ 2 weeks ago 3 │ games │ Dir │ 4.1 KB │ a month ago 4 │ github │ Dir │ 4.1 KB │ 3 hours ago 5 │ java │ Dir │ 4.1 KB │ a month ago 6 │ joplin │ Dir │ 4.1 KB │ 2 months ago ───┴──────────────────────┴──────┴──────────┴────────────── Wait why is there a table? Everything is structured data in nushell. This table is actually stuctured data and is interactive. we can convert this table to json using ls | to json, or convert to csv using ls | to csv. if we don’t know what type of conversion is possible so we can even ls | to --help to get all the possible conversion formats.\n Second, we use where subcommand for filtering table to match the condition. If you look again at the table above there is a type column and its contents are either File or Dir. so we can use ls | where type == Dir for filtering out the directory.  ls | where type == Dir | | column unique value in column ───┬────────────────┬──────┬────────┬────────────── # │ name │ type │ size │ modified ───┼────────────────┼──────┼────────┼────────────── 0 │ asset │ Dir │ 4.1 KB │ 2 months ago 1 │ course 4th Sem │ Dir │ 4.1 KB │ 2 weeks ago 2 │ games │ Dir │ 4.1 KB │ a month ago 3 │ github │ Dir │ 4.1 KB │ 4 hours ago 4 │ java │ Dir │ 4.1 KB │ a month ago 5 │ joplin │ Dir │ 4.1 KB │ 2 months ago ───┴────────────────┴──────┴────────┴──────────────  What if we want all the unique values present in type column. Since nushell has dataframes, we can leverage it to get the unique types. We convert our table to dataframe then select the type column and then list all the unique values present in the column. The whole thing looks like\nls | dataframe to-df | $in.type | dataframe unique\n  Third, We will iterate through each row using each and for each row we will retrieve its name then check the size with du $it.name.  $it is a variable that stores row that is currently pointed during iteration process.\n───┬────────────────┬──────────┬──────────┬─────────────────┬ # │ path │ apparent │ physical │ directories │ ───┼────────────────┼──────────┼──────────┼─────────────────┼ 0 │ asset │ 19.9 MB │ 19.9 MB │ │ 1 │ course 4th Sem │ 3.7 MB │ 3.7 MB │ [table 1 rows] │ 2 │ games │ 15.0 KB │ 98.3 KB │ │ 3 │ github │ 23.1 GB │ 24.5 GB │ [table 47 rows] │ 4 │ java │ 225.6 KB │ 380.9 KB │ [table 4 rows] │ 5 │ joplin │ 212.0 KB │ 368.6 KB │ [table 8 rows] │ ───┴────────────────┴──────────┴──────────┴─────────────────┴ We again get a table with columns path, apparent, and physical.\n Fourth, We will get all the rows whose physical column values are greater than 1000mb with  ls | where type == Dir | each { du $it.name } | where physical  1000mb ───┬────────┬──────────┬──────────┬─────────────────┬─────── # │ path │ apparent │ physical │ directories │ files ───┼────────┼──────────┼──────────┼─────────────────┼─────── 0 │ github │ 23.1 GB │ 24.5 GB │ [table 47 rows] │ ───┴────────┴──────────┴──────────┴─────────────────┴─────── Fetching Quotes from internet in nushell I was looking through public-api list and found this gem themotivate365 that serves random stoic quotes.\nHere is the random quote retrieved by Curl\n curl -L https://api.themotivate365.com/stoic-quote {\"data\":{\"author\":\"Nassim Nicholas Taleb\",\"quote\":\"Weak men act to satisfy their needs, stronger men their duties.\"}}⏎ So we get JSON as a response. With nushell this is a cakewalk as structured data is its first class citizen.\n fetch \"https://api.themotivate365.com/stoic-quote\" ───┬──────────────────── # │ data ───┼──────────────────── 0 │ [row author quote] ───┴──────────────────── As you can see the json is already parsed and converted to table. Now to get the quote we can use\nfetch \"https://api.themotivate365.com/stoic-quote\" | get data.quote This shows how flexible is it to work with structured data actually in nushell. here are some of the cool oneliners that i randomly grabbed from discord nushell community.\njon#6709 :\nQuery Wolfram Alpha\ndef w [...query] { let appID = # Get one at https://products.wolframalpha.com/api/ let queryString = ($query | str collect ' ') let result = (fetch (\"https://api.wolframalpha.com/v1/result?\" + ([[appid i]; [$appID $queryString]] | to url))) $result + \"\" } ","wordCount":"1291","inLanguage":"en","datePublished":"2022-01-29T20:07:44+05:45","dateModified":"2022-01-29T20:07:44+05:45","mainEntityOfPage":{"@type":"WebPage","@id":"https://voidash.github.io/blog/posts/2022/introducing-nushell/"},"publisher":{"@type":"Organization","name":"AshLogs","logo":{"@type":"ImageObject","url":"https://voidash.github.io/blog/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://voidash.github.io/blog/ accesskey=h title="AshLogs (Alt + H)">AshLogs</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://voidash.github.io/blog/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://voidash.github.io/blog/joy-and-curiosity/ title="Joy and Curiosity">
<span>Joy and Curiosity</span>
</a>
</li>
<li>
<a href=https://voidash.github.io/blog/random/ title=Random>
<span>Random</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Introducing Nushell
</h1>
<div class=post-meta><span title="2022-01-29 20:07:44 +0545 +0545">January 29, 2022</span>
</div>
</header>
<div class=post-content><p>At it&rsquo;s core Shells are just interactive user interface that exposes OS tools and services. This blog is a introduction to <strong>Nushell</strong> , a cross-platform shell written in Rust . We already have had fair share of shells like Bash, Zsh, Fish etc. Why do we need yet another shell? All existing shells have one thing in common, They all treat as if <strong>everything is a text</strong>. Enter <strong>Nushell</strong> where <strong>Everything is a structured data</strong>.</p>
<h2 id=bash-and-nushell--head-to-head>Bash and Nushell : Head to Head<a hidden class=anchor aria-hidden=true href=#bash-and-nushell--head-to-head>#</a></h2>
<h3 id=bash>Bash<a hidden class=anchor aria-hidden=true href=#bash>#</a></h3>
<p>lets say <strong>you need to list directories only in bash</strong>.</p>
<p><code>ls -l | grep ^d</code> will do the trick. How does this work? When you <code>ls</code> and look at each line, The line with directories will always have <code>d</code> present as a first character. Something like this</p>
<pre tabindex=0><code>drwxr-xr-x  8 cdjk cdjk      4096 Jan 24 18:44  Documents
|
┴── First character is d

</code></pre><p>So we list all the contents in current directory then pipe it to <code>grep</code> command which looks for all the <em>lines</em> in a piped <strong>text</strong> that starts with <code>d</code>. Now that is not bad for a bash script.</p>
<p><strong>what if we want to get all the directories , then get its size and later list only those that are bigger than 1 gigabyte</strong>. Try doing that using <code>ls</code> and <code>grep</code>.</p>
<p>For this scenario one option is to <code>du -sm * | awk '$1 > 1000'</code> where <code>du -sm *</code> gets the size and name of files present in the current directory seperated by space. The output without the awk part will be</p>
<pre tabindex=0><code>331	Desktop
209	Devanagari-To-Braille-DTB
1	develop
20887	Documents
11734	Downloads
</code></pre><p>Awk is a mini excel basically. From the <code>awk</code> perspective the above output by <code>du</code> has two fields : <code>$1</code> and <code>$2</code> seperated by space. <em>First</em> field or <code>$1</code> is numeric. i.e <code>331</code>, <code>209</code>. It is actually a size of the file present in <em>second</em> field. i.e <code>Desktop</code>, <code>Documents</code></p>
<p><code>awk '$1 > 1000'</code> will compare the first field or size that&rsquo;s bigger than 1000mb and print only those lines that meet the criteria. So when piped together to form <code>du -sm * | awk '$1 > 1000'</code> This will list the contents with size bigger than 1000mb.</p>
<p>Those two tasks of <em>listing directory only</em> and <em>getting directory with size bigger than 1000mb</em> look similar but we used 4 tools. For first tak we used <code>ls</code> and <code>grep</code>. For second task we used <code>du</code> and <code>awk</code>. It&rsquo;s really a burden when scripting in bash due to sheer amount of tools and types of workflows present in bash. my thought process while scripting in bash is first google, then look at man pages to fit the criteria in a loop until whole script is complete and this process is really tiresome.</p>
<h3 id=nushell>Nushell<a hidden class=anchor aria-hidden=true href=#nushell>#</a></h3>
<p><strong>Nushell</strong> is different and intuitive. To demostrate that Lets perform the same task in nushell.</p>
<p><code>ls | where type == Dir | each { du $it.name } | where physical > 1000mb</code>.</p>
<p>Doesn&rsquo;t it look comprehensive than the bash counterpart. Isn&rsquo;t it intuitive? and all in all we are just using commands <code>ls</code> and <code>du</code>.</p>
<p>Here is the whole process dissected for better understanding plus some features about nushell.</p>
<ul>
<li>First list the contents in directory using <code>ls</code></li>
</ul>
<pre tabindex=0><code>───┬──────────────────────┬──────┬──────────┬──────────────
 # │         name         │ type │   size   │   modified   
───┼──────────────────────┼──────┼──────────┼──────────────
 0 │ 2022-01-24_18-44.png │ File │ 281.0 KB │ 5 days ago   
 1 │ asset                │ Dir  │   4.1 KB │ 2 months ago 
 2 │ course 4th Sem       │ Dir  │   4.1 KB │ 2 weeks ago  
 3 │ games                │ Dir  │   4.1 KB │ a month ago  
 4 │ github               │ Dir  │   4.1 KB │ 3 hours ago  
 5 │ java                 │ Dir  │   4.1 KB │ a month ago  
 6 │ joplin               │ Dir  │   4.1 KB │ 2 months ago 
───┴──────────────────────┴──────┴──────────┴──────────────
</code></pre><p>Wait why is there a table? Everything is structured data in nushell. This table is actually stuctured data and is interactive. we can convert this table to <strong>json</strong> using <code>ls | to json</code>, or convert to <strong>csv</strong> using <code>ls | to csv</code>. if we don&rsquo;t know what type of conversion is possible so we can even <code>ls | to --help</code> to get all the possible conversion formats.</p>
<ul>
<li>Second, we use <code>where</code> subcommand for filtering table to match the condition. If you look again at the table above there is a <code>type</code> column and its contents are either <code>File</code> or <code>Dir</code>. so we can use <code>ls | where type == Dir</code> for filtering out the directory.</li>
</ul>
<pre tabindex=0><code>ls | where type == Dir
            |       |
         column   unique value in column    
</code></pre><pre tabindex=0><code>───┬────────────────┬──────┬────────┬──────────────
 # │      name      │ type │  size  │   modified   
───┼────────────────┼──────┼────────┼──────────────
 0 │ asset          │ Dir  │ 4.1 KB │ 2 months ago 
 1 │ course 4th Sem │ Dir  │ 4.1 KB │ 2 weeks ago  
 2 │ games          │ Dir  │ 4.1 KB │ a month ago  
 3 │ github         │ Dir  │ 4.1 KB │ 4 hours ago  
 4 │ java           │ Dir  │ 4.1 KB │ a month ago  
 5 │ joplin         │ Dir  │ 4.1 KB │ 2 months ago 
───┴────────────────┴──────┴────────┴──────────────
</code></pre><blockquote>
<p>What if we want all the unique values present in <code>type</code> column. Since nushell has dataframes, we can leverage it to get the unique types. We convert our table to dataframe then select the <code>type</code> column and then list all the unique values present in the column. The whole thing looks like</p>
<p><code>ls | dataframe to-df | $in.type | dataframe unique</code></p>
</blockquote>
<ul>
<li>Third, We will iterate through each row using <code>each</code> and for each row we will retrieve its name then check the size with <code>du $it.name</code>.</li>
</ul>
<p><code>$it</code> is a variable that stores row that is currently pointed during iteration process.</p>
<pre tabindex=0><code>───┬────────────────┬──────────┬──────────┬─────────────────┬
 # │      path      │ apparent │ physical │   directories   │ 
───┼────────────────┼──────────┼──────────┼─────────────────┼
 0 │ asset          │  19.9 MB │  19.9 MB │                 │       
 1 │ course 4th Sem │   3.7 MB │   3.7 MB │ [table 1 rows]  │       
 2 │ games          │  15.0 KB │  98.3 KB │                 │       
 3 │ github         │  23.1 GB │  24.5 GB │ [table 47 rows] │       
 4 │ java           │ 225.6 KB │ 380.9 KB │ [table 4 rows]  │       
 5 │ joplin         │ 212.0 KB │ 368.6 KB │ [table 8 rows]  │       
───┴────────────────┴──────────┴──────────┴─────────────────┴
</code></pre><p>We again get a table with columns <code>path</code>, <code>apparent</code>, and <code>physical</code>.</p>
<ul>
<li>Fourth, We will get all the rows whose <code>physical column</code> values are greater than 1000mb with</li>
</ul>
<pre tabindex=0><code>ls | where type == Dir | each { du $it.name } | where physical &gt; 1000mb

───┬────────┬──────────┬──────────┬─────────────────┬───────
 # │  path  │ apparent │ physical │   directories   │ files 
───┼────────┼──────────┼──────────┼─────────────────┼───────
 0 │ github │  23.1 GB │  24.5 GB │ [table 47 rows] │       
───┴────────┴──────────┴──────────┴─────────────────┴───────
</code></pre><h2 id=fetching-quotes-from-internet-in-nushell>Fetching Quotes from internet in nushell<a hidden class=anchor aria-hidden=true href=#fetching-quotes-from-internet-in-nushell>#</a></h2>
<p>I was looking through <a href=https://github.com/public-apis/public-apis>public-api</a> list and found this gem <a href=https://api.themotivate365.com/stoic-quote>themotivate365</a> that serves random stoic quotes.</p>
<p>Here is the random quote retrieved by Curl</p>
<pre tabindex=0><code>&gt; curl -L https://api.themotivate365.com/stoic-quote

{&quot;data&quot;:{&quot;author&quot;:&quot;Nassim Nicholas Taleb&quot;,&quot;quote&quot;:&quot;Weak men act to satisfy their needs, stronger men their duties.&quot;}}⏎
</code></pre><p>So we get JSON as a response. With nushell this is a cakewalk as structured data is its first class citizen.</p>
<pre tabindex=0><code>&gt; fetch &quot;https://api.themotivate365.com/stoic-quote&quot;
───┬────────────────────
 # │        data        
───┼────────────────────
 0 │ [row author quote] 
───┴────────────────────

</code></pre><p>As you can see the json is already parsed and converted to table. Now to get the quote we can use</p>
<pre tabindex=0><code>fetch &quot;https://api.themotivate365.com/stoic-quote&quot; | get data.quote
</code></pre><p>This shows how flexible is it to work with structured data actually in nushell. here are some of the cool oneliners that i randomly grabbed from discord nushell community.</p>
<p>jon#6709 :</p>
<p>Query Wolfram Alpha</p>
<pre tabindex=0><code>def w [...query] {
    let appID = # Get one at https://products.wolframalpha.com/api/
    let queryString = ($query | str collect ' ')
    let result = (fetch (&quot;https://api.wolframalpha.com/v1/result?&quot; + ([[appid i]; [$appID $queryString]] | to url)))
    $result + &quot;&quot;
}
</code></pre>
</div>
<footer class=post-footer>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2025 <a href=https://voidash.github.io/blog/>AshLogs</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><style>.first{width:100%;display:flex;align-items:center;justify-content:center}.comments{margin:10px;width:60%}</style>
<div class=first>
<div class=comments>
<script src=https://giscus.app/client.js data-repo=voidash/blog data-repo-id=R_kgDOGcYJSw data-category=General data-category-id=DIC_kwDOGcYJS84CnRjF data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script>
</div>
</div>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>